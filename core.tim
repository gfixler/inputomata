(defn inputomata [states]
  (loop [cur-state :start]
        (if-let [state (states cur-state)]
                (do (when-let [msg (state :msg)]
                              (print "\r" (repeat " " (- (#*winwidth ".") 1)))
                              (if (string? msg)
                                (print "\r" msg)
                                (print "\r" (msg))))
                  (let [k (nr2char (#*getchar))]
                    (if (contains? state k)
                      (let (v (state k))
                        (if (nil? v)
                          "done"
                          (if (keyword? v)
                            (recur v)
                            (do
                              (v)
                              (recur cur-state)))))
                      (recur cur-state))))
                (throw (str "no '" cur-state "' state")))))

(let [r (atom 0)
      g (atom 0)
      b (atom 0)]
  (inputomata {:start {:msg "Choose component (r/g/b/q): "
                       \r :red
                       \g :green
                       \b :blue
                       \q nil}
               :red {:msg "Set the RED component value (j/k/r/g/b/m/q): "
                     \m :start
                     \g :green
                     \b :blue
                     \j #(swap! r inc)
                     \k #(swap! r dec)
                     \q nil}
               :green {:msg "Set the GREEN component value (j/k/r/g/b/m/q): "
                       \m :start
                       \r :red
                       \b :blue
                       \j #(swap! g inc)
                       \k #(swap! g dec)
                       \q nil}
               :blue {:msg "Set the BLUE component value (j/k/r/g/b/m/q): "
                      \m :start
                      \r :red
                      \g :green
                      \j #(swap! b inc)
                      \k #(swap! b dec)
                      \q nil}}))

