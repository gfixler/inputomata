(defn inputomata [states-map]
  (loop [state-name :start]
        (if (not (contains? states-map state-name))
          (throw (str "no state :" state-name)))
        (let [state-map (states-map state-name)]
          (when-let [msg (:msg state-map)]
                    (echo msg))
          (let [state-key (nr2char (#*getchar))]
            (if (contains? state-map state-key)
              (let [action (state-map state-key)]
                (if action
                  (if (keyword? action)
                    (recur action)
                    (do
                      (action)
                      (recur state-name)))
                  "Terminated normally."))
              (recur (state-map state-key)))))))

(let [r (atom 0)
      g (atom 0)
      b (atom 0)]
  (inputomata {:start {:msg "Choose component (r/g/b/q): "
                       \r :red
                       \g :green
                       \b :blue
                       \q nil}
               :red {:msg "Set the RED component value (j/k/r/g/b/m/q): "
                     \m :start
                     \g :green
                     \b :blue
                     \j #(swap! r inc)
                     \k #(swap! r dec)
                     \q nil}
               :green {:msg "Set the GREEN component value (j/k/r/g/b/m/q): "
                       \m :start
                       \r :red
                       \b :blue
                       \j #(swap! g inc)
                       \k #(swap! g dec)
                       \q nil}
               :blue {:msg "Set the BLUE component value (j/k/r/g/b/m/q): "
                      \m :start
                      \r :red
                      \g :green
                      \j #(swap! b inc)
                      \k #(swap! b dec)
                      \q nil}}))

